# Test Design: Story 4.3.2 - Fantrax Account Page Enhancement

**Story:** 4.3.2 Fantrax Account Page Enhancement with In-Browser Authentication
**Epic:** 4.3 Fantrax League Integration
**Date:** 2025-10-14
**Designer:** Quinn (Test Architect)
**Risk Profile Reference:** [4.3.2-risk-20251014.md](./4.3.2-risk-20251014.md)

---

## Test Strategy Overview

### Test Distribution
- **Total test scenarios:** 67
- **Unit tests:** 28 (42%)
- **Integration tests:** 26 (39%)
- **E2E tests:** 13 (19%)

### Priority Distribution
- **P0 (Critical):** 32 tests (48%) - Security, resource management, auth flow
- **P1 (High):** 22 tests (33%) - Core functionality, UX
- **P2 (Medium):** 11 tests (16%) - Secondary features, edge cases
- **P3 (Low):** 2 tests (3%) - Nice-to-have

### Risk Coverage
- **All 13 identified risks** have dedicated test coverage
- **Focus areas:** Selenium resource management (Risk 1.1), Security (Risk 2.1, 2.2), Performance (Risk 3.1)

### Testing Philosophy
This feature has elevated risk due to server-side Selenium automation. Test strategy emphasizes:
1. **Defense in depth** - Critical paths tested at all levels
2. **Failure mode coverage** - Extensive error scenario testing
3. **Resource safety** - Comprehensive cleanup validation
4. **Security first** - Session isolation, encryption, access control

---

## Test Scenarios by Acceptance Criteria

### AC1: Unified Account Page Structure

**Requirements:**
- New `/app/account/page.tsx` with 4 tabs
- Tab navigation with URL persistence
- Mobile-responsive layout

#### Unit Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-UNIT-001 | P1 | Tab state management logic | Pure state logic, no DOM needed |
| 4.3.2-UNIT-002 | P2 | URL query param parsing for tab selection | Input transformation logic |
| 4.3.2-UNIT-003 | P2 | Tab validation (invalid tab name) | Edge case handling |

**Test Details:**

```typescript
// 4.3.2-UNIT-001: Tab state management
test('switches tab and updates URL param', () => {
  const { result } = renderHook(() => useAccountTabs());
  act(() => result.current.setActiveTab('fantrax'));
  expect(result.current.activeTab).toBe('fantrax');
  expect(mockRouter.push).toHaveBeenCalledWith('/account?tab=fantrax');
});

// 4.3.2-UNIT-002: Query param parsing
test('initializes from URL query param', () => {
  mockRouter.query = { tab: 'subscription' };
  const { result } = renderHook(() => useAccountTabs());
  expect(result.current.activeTab).toBe('subscription');
});

// 4.3.2-UNIT-003: Invalid tab handling
test('defaults to profile tab on invalid query param', () => {
  mockRouter.query = { tab: 'invalid-tab' };
  const { result } = renderHook(() => useAccountTabs());
  expect(result.current.activeTab).toBe('profile');
});
```

#### Integration Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-INT-001 | P1 | Account page renders all 4 tabs | Component integration |
| 4.3.2-INT-002 | P1 | Tab content loads correctly per tab | Content rendering |
| 4.3.2-INT-003 | P2 | Mobile responsive layout renders | Responsive behavior |

**Test Details:**

```typescript
// 4.3.2-INT-001: Tab rendering
test('renders all four tabs', () => {
  render(<AccountPage />);
  expect(screen.getByText('Profile')).toBeInTheDocument();
  expect(screen.getByText('Subscription')).toBeInTheDocument();
  expect(screen.getByText('Fantrax')).toBeInTheDocument();
  expect(screen.getByText('Preferences')).toBeInTheDocument();
});

// 4.3.2-INT-002: Tab content
test('displays correct content for each tab', () => {
  render(<AccountPage />);
  fireEvent.click(screen.getByText('Fantrax'));
  expect(screen.getByText('Fantrax Integration')).toBeInTheDocument();
});

// 4.3.2-INT-003: Mobile responsiveness (viewport testing)
test('adapts tab layout for mobile', () => {
  global.innerWidth = 375;
  render(<AccountPage />);
  expect(screen.getByTestId('mobile-tab-dropdown')).toBeInTheDocument();
});
```

#### E2E Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-E2E-001 | P1 | User navigates between all tabs | Critical navigation path |

**Test Details:**

```typescript
// 4.3.2-E2E-001: Tab navigation
test('user can navigate all account tabs', async () => {
  await page.goto('/account');
  await page.click('text=Subscription');
  await expect(page).toHaveURL('/account?tab=subscription');
  await page.click('text=Fantrax');
  await expect(page).toHaveURL('/account?tab=fantrax');
  await page.click('text=Profile');
  await expect(page).toHaveURL('/account?tab=profile');
});
```

---

### AC2: In-Browser Fantrax Authentication (Backend)

**Requirements:**
- `/api/fantrax/auth/initiate` endpoint
- `/api/fantrax/auth/status` polling endpoint
- `/api/fantrax/auth/complete` endpoint
- Session isolation, timeout handling, cleanup

**Mitigates Risks:** 1.1 (Resource Exhaustion), 1.2 (Orphaned Processes), 1.3 (Driver Compatibility), 2.2 (Session Hijacking)

#### Unit Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-UNIT-004 | P0 | Session ID generation is cryptographically secure | Security-critical |
| 4.3.2-UNIT-005 | P0 | Session timeout calculation logic | Resource management |
| 4.3.2-UNIT-006 | P1 | Session status enum transitions | State machine logic |
| 4.3.2-UNIT-007 | P2 | Session ID validation (format) | Input validation |

**Test Details:**

```python
# 4.3.2-UNIT-004: Secure session ID generation
def test_session_id_is_uuid4():
    session_id = FantraxCookieService.generate_session_id()
    assert uuid.UUID(session_id).version == 4  # UUID4 is random

# 4.3.2-UNIT-005: Timeout calculation
def test_session_timeout_is_90_seconds():
    session = AuthSession(created_at=datetime.utcnow())
    assert session.expires_at == session.created_at + timedelta(seconds=90)

# 4.3.2-UNIT-006: Status transitions
def test_session_status_transitions():
    session = AuthSession(status=AuthStatus.INITIALIZING)
    session.mark_ready()
    assert session.status == AuthStatus.READY
    session.mark_authenticating()
    assert session.status == AuthStatus.AUTHENTICATING

# 4.3.2-UNIT-007: Session ID validation
def test_rejects_invalid_session_id():
    with pytest.raises(ValueError):
        validate_session_id("not-a-uuid")
```

#### Integration Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-INT-004 | P0 | POST /auth/initiate creates Selenium session | Critical path start |
| 4.3.2-INT-005 | P0 | GET /auth/status returns correct session state | Status polling |
| 4.3.2-INT-006 | P0 | POST /auth/complete captures and encrypts cookies | Critical path end |
| 4.3.2-INT-007 | P0 | Session cleanup on timeout | Resource management |
| 4.3.2-INT-008 | P0 | Session cleanup on user cancellation | Resource management |
| 4.3.2-INT-009 | P0 | Rate limiting enforced (1 per user per 30s) | DDoS prevention |
| 4.3.2-INT-010 | P0 | Concurrent session limit enforced (max 10) | Resource protection |
| 4.3.2-INT-011 | P0 | User cannot access another user's session | Security |
| 4.3.2-INT-012 | P1 | Selenium driver initialization succeeds | Driver setup |
| 4.3.2-INT-013 | P1 | Browser navigates to Fantrax login page | Auth flow |
| 4.3.2-INT-014 | P2 | Session ID exposed in status endpoint | API contract |
| 4.3.2-INT-015 | P2 | Error returned when Selenium unavailable | Graceful degradation |

**Test Details:**

```python
# 4.3.2-INT-004: Initiate auth session
async def test_initiate_creates_session(client, auth_headers):
    response = await client.post("/api/fantrax/auth/initiate", headers=auth_headers)
    assert response.status_code == 201
    data = response.json()
    assert "session_id" in data
    assert "status_url" in data
    # Verify session exists in memory
    assert data["session_id"] in active_sessions

# 4.3.2-INT-005: Status polling
async def test_status_returns_current_state(client, auth_headers, test_session):
    response = await client.get(f"/api/fantrax/auth/status/{test_session.id}", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ready"
    assert "current_url" in data

# 4.3.2-INT-006: Complete auth and encrypt cookies
async def test_complete_captures_cookies(client, auth_headers, test_session, mock_cookies):
    test_session.cookies = mock_cookies
    response = await client.post(f"/api/fantrax/auth/complete/{test_session.id}", headers=auth_headers)
    assert response.status_code == 200
    # Verify cookies encrypted in database
    user = await db.get(User, auth_headers["user_id"])
    assert user.fantrax_cookies is not None
    assert "fantrax.com" not in user.fantrax_cookies  # Not plaintext
    assert user.fantrax_connected_at is not None

# 4.3.2-INT-007: Timeout cleanup
async def test_session_cleaned_up_on_timeout(client, auth_headers):
    response = await client.post("/api/fantrax/auth/initiate", headers=auth_headers)
    session_id = response.json()["session_id"]
    # Fast-forward time 91 seconds
    with freeze_time("2025-01-01 00:01:31"):
        await cleanup_expired_sessions()
    # Verify session removed
    assert session_id not in active_sessions
    # Verify browser process killed
    assert not process_exists(active_sessions[session_id].pid)

# 4.3.2-INT-008: User cancellation cleanup
async def test_cancel_cleans_up_session(client, auth_headers, test_session):
    response = await client.delete(f"/api/fantrax/auth/cancel/{test_session.id}", headers=auth_headers)
    assert response.status_code == 200
    assert test_session.id not in active_sessions
    assert not process_exists(test_session.pid)

# 4.3.2-INT-009: Rate limiting
async def test_rate_limit_one_session_per_30_seconds(client, auth_headers):
    # First request succeeds
    response1 = await client.post("/api/fantrax/auth/initiate", headers=auth_headers)
    assert response1.status_code == 201
    # Second immediate request fails
    response2 = await client.post("/api/fantrax/auth/initiate", headers=auth_headers)
    assert response2.status_code == 429
    assert "Try again in" in response2.json()["detail"]

# 4.3.2-INT-010: Concurrent session limit
async def test_global_concurrent_session_limit(client, premium_users):
    # Create 10 sessions (max)
    sessions = []
    for user in premium_users[:10]:
        response = await client.post("/api/fantrax/auth/initiate", headers=user.auth_headers)
        assert response.status_code == 201
        sessions.append(response.json()["session_id"])
    # 11th session fails
    response = await client.post("/api/fantrax/auth/initiate", headers=premium_users[10].auth_headers)
    assert response.status_code == 503
    assert "Service temporarily unavailable" in response.json()["detail"]

# 4.3.2-INT-011: Session isolation
async def test_user_cannot_access_other_session(client, user1_headers, user2_headers):
    # User 1 creates session
    response = await client.post("/api/fantrax/auth/initiate", headers=user1_headers)
    session_id = response.json()["session_id"]
    # User 2 tries to access
    response = await client.get(f"/api/fantrax/auth/status/{session_id}", headers=user2_headers)
    assert response.status_code == 403
    assert "Not authorized" in response.json()["detail"]

# 4.3.2-INT-012: Selenium initialization
async def test_selenium_driver_initializes():
    service = FantraxCookieService()
    session_id = await service.create_auth_session(user_id=1)
    session = active_sessions[session_id]
    assert session.driver is not None
    assert session.driver.current_url.startswith("https://www.fantrax.com")

# 4.3.2-INT-013: Browser navigation
async def test_browser_navigates_to_login_page():
    service = FantraxCookieService()
    session_id = await service.create_auth_session(user_id=1)
    session = active_sessions[session_id]
    await asyncio.sleep(3)  # Wait for navigation
    assert "login" in session.driver.current_url.lower()

# 4.3.2-INT-014: Status endpoint contract
async def test_status_endpoint_includes_required_fields(client, auth_headers, test_session):
    response = await client.get(f"/api/fantrax/auth/status/{test_session.id}", headers=auth_headers)
    data = response.json()
    assert "session_id" in data
    assert "status" in data
    assert "current_url" in data
    assert "elapsed_seconds" in data

# 4.3.2-INT-015: Selenium unavailable graceful failure
async def test_selenium_unavailable_returns_error(client, auth_headers, mock_selenium_failure):
    response = await client.post("/api/fantrax/auth/initiate", headers=auth_headers)
    assert response.status_code == 503
    assert "Browser authentication temporarily unavailable" in response.json()["detail"]
```

#### E2E Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-E2E-002 | P0 | Complete auth flow (initiate â†’ status â†’ complete) | Critical revenue path |
| 4.3.2-E2E-003 | P0 | Auth timeout after 90 seconds | Critical failure mode |
| 4.3.2-E2E-004 | P1 | User cancels authentication mid-flow | User control path |

**Test Details:**

```python
# 4.3.2-E2E-002: Full auth flow (SEMI-MANUAL - requires human login)
async def test_complete_auth_flow_with_human_login(page, premium_user):
    # 1. Navigate to account page
    await page.goto('/account?tab=fantrax')
    # 2. Click Connect Fantrax
    await page.click('button:has-text("Connect Fantrax")')
    # 3. Wait for modal
    await page.wait_for_selector('[data-testid="fantrax-auth-modal"]')
    await page.wait_for_selector('text=Initializing browser')
    # 4. Wait for ready state (15 seconds max)
    await page.wait_for_selector('text=Please log in to Fantrax', timeout=15000)
    # 5. MANUAL: Tester logs in (30 seconds)
    await page.wait_for_selector('text=Capturing authentication', timeout=40000)
    # 6. Wait for success
    await page.wait_for_selector('text=Connected!', timeout=10000)
    # 7. Verify connection status
    await expect(page.locator('[data-testid="connection-status"]')).toContainText('Connected')
    # 8. Verify leagues loaded
    await expect(page.locator('[data-testid="league-selector"]')).toBeVisible()

# 4.3.2-E2E-003: Auth timeout
async def test_auth_times_out_after_90_seconds(page, premium_user):
    await page.goto('/account?tab=fantrax')
    await page.click('button:has-text("Connect Fantrax")')
    # Don't log in - let it timeout
    await page.wait_for_selector('text=Authentication timed out', timeout=95000)
    await expect(page.locator('[data-testid="error-message"]')).toContainText('Please try again')
    await expect(page.locator('button:has-text("Retry")')).toBeVisible()

# 4.3.2-E2E-004: User cancellation
async def test_user_cancels_authentication(page, premium_user):
    await page.goto('/account?tab=fantrax')
    await page.click('button:has-text("Connect Fantrax")')
    await page.wait_for_selector('text=Please log in to Fantrax')
    # Click cancel
    await page.click('button:has-text("Cancel")')
    # Verify modal closed
    await expect(page.locator('[data-testid="fantrax-auth-modal"]')).not.toBeVisible()
    # Verify still disconnected
    await expect(page.locator('[data-testid="connection-status"]')).toContainText('Not connected')
```

---

### AC3: In-Browser Authentication UI (Frontend)

**Requirements:**
- "Connect Fantrax" initiates flow
- Auth modal with progress indicators
- Real-time status updates (polling)
- Error handling and retry

**Mitigates Risks:** 3.1 (Authentication Latency), 5.1 (Low Adoption)

#### Unit Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-UNIT-008 | P1 | Auth modal state transitions | State machine logic |
| 4.3.2-UNIT-009 | P1 | Polling interval calculation | Timing logic |
| 4.3.2-UNIT-010 | P1 | Progress indicator updates based on status | UI state logic |
| 4.3.2-UNIT-011 | P2 | Elapsed time calculation | Time formatting |
| 4.3.2-UNIT-012 | P2 | Error message mapping from API errors | Error handling |

**Test Details:**

```typescript
// 4.3.2-UNIT-008: Modal state transitions
test('modal transitions through auth states', () => {
  const { result } = renderHook(() => useFantraxAuth());
  expect(result.current.authState).toBe('idle');
  act(() => result.current.initiateAuth());
  expect(result.current.authState).toBe('initializing');
  act(() => result.current.handleStatusUpdate({ status: 'ready' }));
  expect(result.current.authState).toBe('ready');
});

// 4.3.2-UNIT-009: Polling interval
test('polls every 2 seconds during auth', () => {
  jest.useFakeTimers();
  const pollFn = jest.fn();
  const { result } = renderHook(() => useAuthPolling(pollFn));
  act(() => result.current.startPolling());
  jest.advanceTimersByTime(2000);
  expect(pollFn).toHaveBeenCalledTimes(1);
  jest.advanceTimersByTime(2000);
  expect(pollFn).toHaveBeenCalledTimes(2);
});

// 4.3.2-UNIT-010: Progress indicator
test('shows correct progress message per state', () => {
  expect(getProgressMessage('initializing')).toBe('Initializing browser (5-15 seconds)...');
  expect(getProgressMessage('ready')).toBe('Please log in to Fantrax');
  expect(getProgressMessage('authenticating')).toBe('Capturing authentication...');
});

// 4.3.2-UNIT-011: Elapsed time display
test('formats elapsed time correctly', () => {
  expect(formatElapsedTime(0)).toBe('0s');
  expect(formatElapsedTime(15)).toBe('15s');
  expect(formatElapsedTime(65)).toBe('1m 5s');
});

// 4.3.2-UNIT-012: Error message mapping
test('maps API error to user-friendly message', () => {
  expect(mapAuthError({ code: 'TIMEOUT' })).toBe('Authentication timed out. Please try again.');
  expect(mapAuthError({ code: 'SELENIUM_UNAVAILABLE' })).toBe('Browser authentication temporarily unavailable.');
});
```

#### Integration Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-INT-016 | P0 | Auth modal renders and initiates backend flow | Component integration |
| 4.3.2-INT-017 | P0 | Polling starts and fetches status updates | API integration |
| 4.3.2-INT-018 | P0 | Success state closes modal and updates connection | Happy path |
| 4.3.2-INT-019 | P1 | Error state displays message with retry button | Error handling |
| 4.3.2-INT-020 | P1 | Cancel button stops polling and closes modal | User control |
| 4.3.2-INT-021 | P2 | Progress bar visual updates | Visual feedback |

**Test Details:**

```typescript
// 4.3.2-INT-016: Modal render and initiate
test('clicking Connect opens modal and initiates auth', async () => {
  mockApiClient.post.mockResolvedValueOnce({ session_id: 'test-123', status_url: '/status/test-123' });
  render(<FantraxConnection />);
  fireEvent.click(screen.getByText('Connect Fantrax'));
  await waitFor(() => {
    expect(screen.getByTestId('fantrax-auth-modal')).toBeInTheDocument();
  });
  expect(mockApiClient.post).toHaveBeenCalledWith('/api/fantrax/auth/initiate');
});

// 4.3.2-INT-017: Status polling
test('polls status endpoint every 2 seconds', async () => {
  jest.useFakeTimers();
  mockApiClient.get.mockResolvedValue({ status: 'ready', current_url: 'https://fantrax.com/login' });
  render(<FantraxAuthModal sessionId="test-123" />);
  await waitFor(() => expect(mockApiClient.get).toHaveBeenCalledTimes(1));
  jest.advanceTimersByTime(2000);
  await waitFor(() => expect(mockApiClient.get).toHaveBeenCalledTimes(2));
  jest.useRealTimers();
});

// 4.3.2-INT-018: Success flow
test('success status closes modal and shows connected', async () => {
  mockApiClient.get.mockResolvedValueOnce({ status: 'success' });
  const onSuccess = jest.fn();
  render(<FantraxAuthModal sessionId="test-123" onSuccess={onSuccess} />);
  await waitFor(() => {
    expect(screen.getByText('Connected!')).toBeInTheDocument();
  });
  expect(onSuccess).toHaveBeenCalled();
});

// 4.3.2-INT-019: Error handling
test('displays error message with retry button', async () => {
  mockApiClient.get.mockResolvedValueOnce({ status: 'failed', error: 'TIMEOUT' });
  render(<FantraxAuthModal sessionId="test-123" />);
  await waitFor(() => {
    expect(screen.getByText(/Authentication timed out/)).toBeInTheDocument();
  });
  expect(screen.getByText('Retry')).toBeInTheDocument();
});

// 4.3.2-INT-020: Cancel button
test('cancel stops polling and closes modal', async () => {
  const onCancel = jest.fn();
  render(<FantraxAuthModal sessionId="test-123" onCancel={onCancel} />);
  fireEvent.click(screen.getByText('Cancel'));
  expect(mockApiClient.delete).toHaveBeenCalledWith('/api/fantrax/auth/cancel/test-123');
  expect(onCancel).toHaveBeenCalled();
});

// 4.3.2-INT-021: Progress bar updates
test('progress bar fills as auth progresses', async () => {
  const { rerender } = render(<AuthProgressBar status="initializing" />);
  expect(screen.getByRole('progressbar')).toHaveAttribute('aria-valuenow', '10');
  rerender(<AuthProgressBar status="ready" />);
  expect(screen.getByRole('progressbar')).toHaveAttribute('aria-valuenow', '50');
  rerender(<AuthProgressBar status="authenticating" />);
  expect(screen.getByRole('progressbar')).toHaveAttribute('aria-valuenow', '80');
});
```

---

### AC4: Fantrax Integration Tab

**Requirements:**
- Connection status display
- Multi-league dropdown selector
- Manual sync controls
- Roster display with filters/sorting
- Premium feature gate

**Mitigates Risks:** 4.2 (Cookie Expiration UX), 5.1 (Low Adoption), 5.2 (Support Burden)

#### Unit Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-UNIT-013 | P1 | League selector state management | State logic |
| 4.3.2-UNIT-014 | P1 | Roster filter logic (position filter) | Pure filtering |
| 4.3.2-UNIT-015 | P1 | Roster sort logic (name, position, team) | Pure sorting |
| 4.3.2-UNIT-016 | P2 | Last sync timestamp formatting | Time formatting |
| 4.3.2-UNIT-017 | P2 | Connection age calculation ("Connected 2 hours ago") | Date math |

**Test Details:**

```typescript
// 4.3.2-UNIT-013: League selection
test('selecting league updates state', () => {
  const leagues = [{ id: '1', name: 'Dynasty League' }, { id: '2', name: 'Keeper League' }];
  const { result } = renderHook(() => useLeagueSelector(leagues));
  act(() => result.current.selectLeague('2'));
  expect(result.current.selectedLeague).toEqual(leagues[1]);
});

// 4.3.2-UNIT-014: Position filter
test('filters roster by position', () => {
  const roster = [
    { name: 'Player 1', position: 'SS' },
    { name: 'Player 2', position: 'SP' },
    { name: 'Player 3', position: '2B' }
  ];
  expect(filterRosterByPosition(roster, 'hitters')).toHaveLength(2);
  expect(filterRosterByPosition(roster, 'pitchers')).toHaveLength(1);
});

// 4.3.2-UNIT-015: Roster sorting
test('sorts roster by name', () => {
  const roster = [{ name: 'Zach' }, { name: 'Adam' }, { name: 'Mike' }];
  const sorted = sortRoster(roster, 'name', 'asc');
  expect(sorted[0].name).toBe('Adam');
  expect(sorted[2].name).toBe('Zach');
});

// 4.3.2-UNIT-016: Last sync timestamp
test('formats last sync time relative', () => {
  const now = new Date('2025-01-01T12:00:00Z');
  const oneHourAgo = new Date('2025-01-01T11:00:00Z');
  expect(formatLastSync(oneHourAgo, now)).toBe('1 hour ago');
});

// 4.3.2-UNIT-017: Connection age
test('calculates connection age', () => {
  const connectedAt = new Date('2025-01-01T00:00:00Z');
  const now = new Date('2025-01-03T00:00:00Z');
  expect(getConnectionAge(connectedAt, now)).toBe('2 days ago');
});
```

#### Integration Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-INT-022 | P0 | Premium gate enforced (non-premium sees upgrade prompt) | Revenue protection |
| 4.3.2-INT-023 | P1 | Disconnected state shows "Connect Fantrax" button | Initial state |
| 4.3.2-INT-024 | P1 | Connected state shows leagues dropdown | Connected state |
| 4.3.2-INT-025 | P1 | "Sync Roster" triggers API call and updates display | Core functionality |
| 4.3.2-INT-026 | P1 | Roster displays players after sync | Data display |
| 4.3.2-INT-027 | P1 | Position filter updates displayed roster | Filtering UI |
| 4.3.2-INT-028 | P2 | Empty roster state shows helpful message | Edge case |
| 4.3.2-INT-029 | P2 | Disconnect removes league data | Cleanup |

**Test Details:**

```typescript
// 4.3.2-INT-022: Premium gate
test('non-premium user sees upgrade prompt', () => {
  mockAuth.currentUser = { ...mockUser, subscription_tier: 'free' };
  render(<FantraxTab />);
  expect(screen.getByText(/Upgrade to Premium/i)).toBeInTheDocument();
  expect(screen.queryByText('Connect Fantrax')).not.toBeInTheDocument();
});

// 4.3.2-INT-023: Disconnected state
test('shows connect button when disconnected', () => {
  mockFantrax.isConnected = false;
  render(<FantraxTab />);
  expect(screen.getByText('Connect Fantrax')).toBeInTheDocument();
  expect(screen.getByText(/Benefits of connecting/i)).toBeInTheDocument();
});

// 4.3.2-INT-024: Connected state
test('shows league selector when connected', async () => {
  mockFantrax.isConnected = true;
  mockFantrax.leagues = [{ league_id: '1', league_name: 'Test League' }];
  render(<FantraxTab />);
  await waitFor(() => {
    expect(screen.getByText('Test League')).toBeInTheDocument();
  });
});

// 4.3.2-INT-025: Manual sync
test('sync roster button triggers API call', async () => {
  mockFantrax.selectedLeague = { league_id: '1', league_name: 'Test League' };
  mockApiClient.post.mockResolvedValueOnce({ success: true });
  render(<FantraxTab />);
  fireEvent.click(screen.getByText('Sync Roster'));
  await waitFor(() => {
    expect(mockApiClient.post).toHaveBeenCalledWith('/api/fantrax-v2/sync', { league_id: '1' });
  });
  expect(screen.getByText(/Syncing/i)).toBeInTheDocument();
});

// 4.3.2-INT-026: Roster display
test('displays roster after sync', async () => {
  mockFantrax.roster = [
    { name: 'Juan Soto', position: 'OF', team: 'NYY', status: 'Active' },
    { name: 'Jacob deGrom', position: 'SP', team: 'TEX', status: 'IL' }
  ];
  render(<RosterDisplay roster={mockFantrax.roster} />);
  expect(screen.getByText('Juan Soto')).toBeInTheDocument();
  expect(screen.getByText('Jacob deGrom')).toBeInTheDocument();
});

// 4.3.2-INT-027: Position filter
test('position filter updates displayed players', () => {
  mockFantrax.roster = [
    { name: 'Juan Soto', position: 'OF' },
    { name: 'Jacob deGrom', position: 'SP' }
  ];
  render(<RosterDisplay roster={mockFantrax.roster} />);
  fireEvent.click(screen.getByText('Pitchers'));
  expect(screen.queryByText('Juan Soto')).not.toBeInTheDocument();
  expect(screen.getByText('Jacob deGrom')).toBeInTheDocument();
});

// 4.3.2-INT-028: Empty roster
test('shows empty state when no roster data', () => {
  mockFantrax.roster = [];
  render(<RosterDisplay roster={mockFantrax.roster} />);
  expect(screen.getByText(/No roster data available/i)).toBeInTheDocument();
});

// 4.3.2-INT-029: Disconnect cleanup
test('disconnect removes all league data', async () => {
  mockFantrax.isConnected = true;
  mockFantrax.leagues = [{ league_id: '1', league_name: 'Test' }];
  render(<FantraxTab />);
  fireEvent.click(screen.getByText('Disconnect'));
  await waitFor(() => {
    expect(mockFantrax.isConnected).toBe(false);
    expect(mockFantrax.leagues).toHaveLength(0);
  });
});
```

#### E2E Tests

| Test ID | Priority | Scenario | Justification |
|---------|----------|----------|---------------|
| 4.3.2-E2E-005 | P1 | Premium user connects, selects league, syncs roster | Complete happy path |
| 4.3.2-E2E-006 | P2 | User switches between multiple leagues | Multi-league support |

**Test Details:**

```typescript
// 4.3.2-E2E-005: Complete Fantrax tab flow
test('user connects, selects league, and syncs roster', async () => {
  await page.goto('/account?tab=fantrax');
  // Connect (assumes auth succeeds via mock)
  await page.click('button:has-text("Connect Fantrax")');
  await page.waitForSelector('text=Connected!');
  // Select league
  await page.click('[data-testid="league-selector"]');
  await page.click('text=Dynasty League 2025');
  // Sync roster
  await page.click('button:has-text("Sync Roster")');
  await page.waitForSelector('text=Last synced:');
  // Verify roster displayed
  await expect(page.locator('[data-testid="roster-table"]')).toBeVisible();
  await expect(page.locator('text=Juan Soto')).toBeVisible();
});

// 4.3.2-E2E-006: Multi-league switching
test('user switches between multiple leagues', async () => {
  await page.goto('/account?tab=fantrax');
  // Assume already connected with 2 leagues
  await page.click('[data-testid="league-selector"]');
  await page.click('text=Dynasty League A');
  await page.waitForSelector('text=Dynasty League A');
  await page.click('button:has-text("Sync Roster")');
  await page.waitForSelector('[data-testid="roster-table"]');
  const rosterA = await page.locator('[data-testid="roster-table"]').textContent();
  // Switch to league B
  await page.click('[data-testid="league-selector"]');
  await page.click('text=Dynasty League B');
  await page.click('button:has-text("Sync Roster")');
  await page.waitForSelector('[data-testid="roster-table"]');
  const rosterB = await page.locator('[data-testid="roster-table"]').textContent();
  // Verify different rosters
  expect(rosterA).not.toBe(rosterB);
});
```

---

### AC5-8: Supporting Features

*Consolidated test scenarios for remaining acceptance criteria*

#### Unit Tests

| Test ID | Priority | Scenario | AC | Justification |
|---------|----------|----------|-----|---------------|
| 4.3.2-UNIT-018 | P0 | Cookie encryption/decryption | AC8 | Security-critical |
| 4.3.2-UNIT-019 | P0 | Premium tier validation logic | AC8 | Access control |
| 4.3.2-UNIT-020 | P1 | API error response parsing | AC5 | Error handling |
| 4.3.2-UNIT-021 | P2 | Mobile breakpoint detection | AC7 | Responsive logic |

**Test Details:**

```python
# 4.3.2-UNIT-018: Cookie encryption
def test_cookie_encryption_decryption():
    cookies = [{"name": "auth_token", "value": "secret123"}]
    encrypted = encrypt_cookies(cookies)
    assert encrypted != str(cookies)  # Not plaintext
    decrypted = decrypt_cookies(encrypted)
    assert decrypted == cookies

# 4.3.2-UNIT-019: Premium validation
def test_premium_tier_check():
    user_free = User(subscription_tier="free")
    user_premium = User(subscription_tier="premium")
    assert not is_premium_user(user_free)
    assert is_premium_user(user_premium)
```

```typescript
// 4.3.2-UNIT-020: API error parsing
test('parses API error responses', () => {
  const error = { response: { status: 401, data: { detail: 'Unauthorized' } } };
  expect(parseApiError(error)).toBe('Unauthorized');
});

// 4.3.2-UNIT-021: Mobile breakpoint
test('detects mobile breakpoint', () => {
  global.innerWidth = 375;
  expect(isMobileViewport()).toBe(true);
  global.innerWidth = 1024;
  expect(isMobileViewport()).toBe(false);
});
```

#### Integration Tests

| Test ID | Priority | Scenario | AC | Justification |
|---------|----------|----------|-----|---------------|
| 4.3.2-INT-030 | P0 | Encrypted cookies stored in database | AC8 | Security verification |
| 4.3.2-INT-031 | P0 | Non-premium user blocked from Fantrax endpoints | AC8 | Access control |
| 4.3.2-INT-032 | P1 | Cookie expiration detected and user notified | AC5 | UX for expired state |
| 4.3.2-INT-033 | P2 | Mobile tab navigation renders correctly | AC7 | Mobile UX |

**Test Details:**

```python
# 4.3.2-INT-030: Encrypted storage
async def test_cookies_stored_encrypted(db, premium_user, mock_cookies):
    await store_fantrax_cookies(db, premium_user.id, mock_cookies)
    user = await db.get(User, premium_user.id)
    # Verify encryption
    assert user.fantrax_cookies != str(mock_cookies)
    assert "auth_token" not in user.fantrax_cookies  # Not plaintext

# 4.3.2-INT-031: Premium enforcement
async def test_free_user_blocked_from_fantrax(client, free_user_headers):
    response = await client.post("/api/fantrax/auth/initiate", headers=free_user_headers)
    assert response.status_code == 403
    assert "premium" in response.json()["detail"].lower()

# 4.3.2-INT-032: Cookie expiration detection
async def test_expired_cookie_shows_reconnect_prompt(client, premium_user_headers):
    # Simulate expired cookies
    response = await client.get("/api/fantrax-v2/leagues", headers=premium_user_headers)
    assert response.status_code == 401
    assert "expired" in response.json()["detail"].lower()
```

```typescript
// 4.3.2-INT-033: Mobile tabs
test('account tabs adapt to mobile', () => {
  global.innerWidth = 375;
  render(<AccountTabs />);
  expect(screen.getByTestId('mobile-tab-dropdown')).toBeInTheDocument();
});
```

#### E2E Tests

| Test ID | Priority | Scenario | AC | Justification |
|---------|----------|----------|-----|---------------|
| 4.3.2-E2E-007 | P0 | Free user sees premium gate on Fantrax tab | AC8 | Revenue protection |
| 4.3.2-E2E-008 | P1 | Expired connection prompts reconnect | AC5 | Cookie lifecycle |
| 4.3.2-E2E-009 | P2 | Mobile user navigates account tabs | AC7 | Mobile UX |

**Test Details:**

```typescript
// 4.3.2-E2E-007: Premium gate enforcement
test('free user blocked from Fantrax tab', async () => {
  await loginAs(page, 'free-user@example.com');
  await page.goto('/account?tab=fantrax');
  await expect(page.locator('text=Upgrade to Premium')).toBeVisible();
  await expect(page.locator('button:has-text("Connect Fantrax")')).not.toBeVisible();
});

// 4.3.2-E2E-008: Expired cookie flow
test('expired connection shows reconnect prompt', async () => {
  // Simulate expired cookies (backend mocked to return 401)
  await page.goto('/account?tab=fantrax');
  await expect(page.locator('text=Your Fantrax connection has expired')).toBeVisible();
  await expect(page.locator('button:has-text("Reconnect")')).toBeVisible();
});

// 4.3.2-E2E-009: Mobile navigation
test('mobile user navigates account tabs', async () => {
  await page.setViewportSize({ width: 375, height: 667 });
  await page.goto('/account');
  await page.click('[data-testid="mobile-tab-dropdown"]');
  await page.click('text=Fantrax');
  await expect(page).toHaveURL('/account?tab=fantrax');
});
```

---

## Risk Coverage Matrix

Mapping test scenarios to identified risks:

| Risk ID | Risk Description | Test IDs Covering Risk | Coverage Level |
|---------|------------------|------------------------|----------------|
| 1.1 | Selenium Resource Exhaustion | INT-007, INT-008, INT-009, INT-010 | âœ… Comprehensive |
| 1.2 | Orphaned Browser Processes | INT-007, INT-008, E2E-003, E2E-004 | âœ… Comprehensive |
| 1.3 | Selenium Driver Compatibility | INT-012, INT-015 | ðŸŸ¡ Basic (relies on monitoring) |
| 2.1 | Cookie Storage Security | UNIT-018, INT-030 | âœ… Comprehensive |
| 2.2 | Session Hijacking | INT-011 | âœ… Comprehensive |
| 2.3 | XSS via User Content | (Covered by framework, manual pen-test) | ðŸŸ¡ Basic |
| 3.1 | Authentication Latency | E2E-002, E2E-003 | âœ… Comprehensive |
| 3.2 | Database Contention | (Load testing - see below) | ðŸŸ¡ Performance test |
| 4.1 | Fantrax API Changes | INT-013, E2E-002 | ðŸŸ¡ Basic (weekly CI) |
| 4.2 | Cookie Expiration UX | INT-032, E2E-008 | âœ… Comprehensive |
| 5.1 | Low Adoption (UX Friction) | E2E-002, E2E-005 (usability) | ðŸŸ¡ User testing |
| 5.2 | Support Burden | INT-019, INT-028 (help text) | ðŸŸ¡ User testing |
| 6.1 | Deployment Complexity | (Deployment smoke test) | ðŸŸ¡ Staging test |

---

## Load & Performance Tests

**Beyond functional tests, these scenarios validate performance and scalability:**

| Test ID | Priority | Scenario | Target Metric | Justification |
|---------|----------|----------|---------------|---------------|
| 4.3.2-LOAD-001 | P0 | 10 concurrent auth sessions | All succeed, <90s each | Risk 1.1 mitigation |
| 4.3.2-LOAD-002 | P0 | 20 concurrent API calls during auth | No DB timeouts | Risk 3.2 mitigation |
| 4.3.2-LOAD-003 | P1 | 100 successive auth sessions | No memory leaks | Risk 1.2 mitigation |
| 4.3.2-PERF-001 | P0 | Account page load time | <2 seconds | NFR requirement |
| 4.3.2-PERF-002 | P0 | Auth completion time (p95) | <75 seconds | Risk 3.1 mitigation |
| 4.3.2-PERF-003 | P1 | Tab switching time | <300ms | NFR requirement |

**Load Test Implementation:**

```python
# 4.3.2-LOAD-001: Concurrent auth sessions
async def test_10_concurrent_auth_sessions():
    users = [create_premium_user() for _ in range(10)]
    tasks = [initiate_auth(user) for user in users]
    start = time.time()
    results = await asyncio.gather(*tasks, return_exceptions=True)
    duration = time.time() - start
    # All should succeed
    assert all(r["status"] == "success" for r in results if not isinstance(r, Exception))
    # All complete within 90 seconds
    assert duration < 90
    # No exceptions
    assert not any(isinstance(r, Exception) for r in results)

# 4.3.2-LOAD-003: Memory leak test
async def test_100_successive_auth_sessions():
    import psutil
    process = psutil.Process()
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    for i in range(100):
        await full_auth_cycle(user_id=i)
    final_memory = process.memory_info().rss / 1024 / 1024
    memory_growth = final_memory - initial_memory
    # Allow 50MB growth max (500KB per session)
    assert memory_growth < 50, f"Memory leaked: {memory_growth}MB"
```

**Performance Test Implementation:**

```typescript
// 4.3.2-PERF-001: Account page load
test('account page loads in under 2 seconds', async () => {
  const start = performance.now();
  await page.goto('/account');
  await page.waitForLoadState('networkidle');
  const duration = performance.now() - start;
  expect(duration).toBeLessThan(2000);
});

// 4.3.2-PERF-003: Tab switching
test('tab switch completes in under 300ms', async () => {
  await page.goto('/account');
  const start = performance.now();
  await page.click('text=Fantrax');
  await page.waitForSelector('[data-testid="fantrax-tab-content"]');
  const duration = performance.now() - start;
  expect(duration).toBeLessThan(300);
});
```

---

## Security Tests

**Dedicated security validation scenarios:**

| Test ID | Priority | Scenario | Attack Vector | Justification |
|---------|----------|----------|---------------|---------------|
| 4.3.2-SEC-001 | P0 | Session ID prediction attempt | Brute force session IDs | Risk 2.2 |
| 4.3.2-SEC-002 | P0 | Cookie plaintext search in DB dump | SQL injection â†’ data dump | Risk 2.1 |
| 4.3.2-SEC-003 | P0 | Premium bypass attempt (JWT manipulation) | Token forgery | Revenue protection |
| 4.3.2-SEC-004 | P1 | XSS payload in league name | Malicious Fantrax data | Risk 2.3 |
| 4.3.2-SEC-005 | P1 | CSRF attack on auth endpoints | Cross-site request | Session security |

**Security Test Implementation:**

```python
# 4.3.2-SEC-001: Session ID prediction
def test_session_ids_unpredictable():
    session_ids = [FantraxCookieService.generate_session_id() for _ in range(100)]
    # All unique
    assert len(set(session_ids)) == 100
    # All valid UUIDs
    assert all(uuid.UUID(sid).version == 4 for sid in session_ids)
    # No sequential pattern
    assert not is_sequential(session_ids)

# 4.3.2-SEC-002: Cookie encryption verification
async def test_no_plaintext_cookies_in_database(db):
    # Store known cookies
    test_cookies = [{"name": "auth_token", "value": "SENSITIVE_DATA_12345"}]
    await store_fantrax_cookies(db, user_id=1, cookies=test_cookies)
    # Dump database (simulate SQL injection)
    db_dump = await db.execute("SELECT fantrax_cookies FROM users WHERE id = 1")
    cookies_field = db_dump.fetchone()[0]
    # Verify plaintext not present
    assert "SENSITIVE_DATA_12345" not in cookies_field
    assert "auth_token" not in cookies_field

# 4.3.2-SEC-003: Premium bypass attempt
async def test_premium_enforcement_server_side(client):
    # Manipulate JWT to claim premium (malicious client)
    fake_premium_token = create_jwt(user_id=1, tier="premium")  # But user is actually free
    headers = {"Authorization": f"Bearer {fake_premium_token}"}
    response = await client.post("/api/fantrax/auth/initiate", headers=headers)
    # Server validates from DB, not token
    assert response.status_code == 403
```

```typescript
// 4.3.2-SEC-004: XSS payload
test('league name with XSS payload is sanitized', () => {
  const maliciousLeague = {
    league_id: '1',
    league_name: '<script>alert("xss")</script>Dynasty League'
  };
  render(<LeagueSelector leagues={[maliciousLeague]} />);
  // Verify script not executed (React escapes by default)
  expect(document.querySelectorAll('script')).toHaveLength(0);
  // Verify displayed safely
  expect(screen.getByText(/Dynasty League/)).toBeInTheDocument();
});
```

---

## Test Execution Strategy

### Execution Order (CI/CD Pipeline)

1. **Unit Tests** (2-3 minutes)
   - Fast feedback
   - Run on every commit
   - Fail fast if business logic broken

2. **Integration Tests** (5-8 minutes)
   - Backend API contracts
   - Frontend component integration
   - Run on PR creation

3. **E2E Tests** (10-15 minutes)
   - Critical paths only
   - Run on PR approval
   - Includes auth flow (semi-manual for now)

4. **Load & Performance Tests** (15-20 minutes)
   - Run nightly on staging
   - Run before production deployment

5. **Security Tests** (5-10 minutes)
   - Run weekly
   - Run before major releases

### Priority-Based Execution

**For rapid iteration (dev environment):**
- P0 Unit + P0 Integration only (~5 min)

**For PR validation (CI):**
- P0 + P1 tests (~15 min)

**For deployment (staging):**
- All P0/P1/P2 + Load tests (~30 min)

**For release (production):**
- Full test suite + Security tests (~45 min)

---

## Test Environment Requirements

### Backend Test Environment
- Python 3.9+
- PostgreSQL test database
- Chrome/Chromium installed
- ChromeDriver compatible version
- Environment variables:
  - `ENCRYPTION_KEY` (test key)
  - `DATABASE_URL` (test DB)
  - `SELENIUM_HEADLESS=true`

### Frontend Test Environment
- Node.js 18+
- Jest + React Testing Library
- Playwright for E2E
- Mock API server (MSW)

### Selenium Test Environment
- **Headless mode** for CI
- **Headed mode** for local debugging
- **Isolation:** Each test gets clean browser instance
- **Cleanup:** Automated process termination

---

## Coverage Goals

### Code Coverage Targets
- **Backend:** >85% line coverage for auth service
- **Frontend:** >80% line coverage for new components
- **Critical paths:** 100% branch coverage (auth flow, premium gate)

### Functional Coverage Targets
- **All acceptance criteria:** 100% covered
- **High risks (>30 score):** Multiple test levels
- **Medium risks (15-29):** At least integration tests
- **Low risks (<15):** Unit tests acceptable

### Regression Coverage
- **All P0 scenarios:** Must pass before deploy
- **Known bugs:** Add regression test before fixing

---

## Test Maintenance Strategy

### Test Stability
- **Avoid hard waits:** Use `waitFor`, `waitForSelector`
- **Unique test IDs:** Use `data-testid` attributes
- **No test interdependence:** Each test runs standalone
- **Cleanup:** Reset state after each test

### Mock Strategy
- **External APIs:** Mock Fantrax API responses
- **Selenium:** Use real browser (integration), mock driver (unit)
- **Database:** Use test DB, not mocks
- **Time:** Mock `Date.now()` for deterministic tests

### CI/CD Integration
- **Parallel execution:** Unit tests run in parallel
- **Fail fast:** Stop on first P0 failure
- **Retry flaky tests:** Max 1 retry for E2E
- **Test reports:** Publish to dashboard

---

## Open Questions & Risks

### Test Risks
1. **E2E Auth Test Requires Human:** Semi-manual test (human must log in)
   - **Mitigation:** Explore Selenium automation of Fantrax login (may violate ToS)
   - **Alternative:** Mock "successful login" state for E2E

2. **Fantrax API Instability:** Tests may fail due to Fantrax changes
   - **Mitigation:** Weekly CI runs detect breakage early
   - **Monitoring:** Track test failure trends

3. **Selenium Flakiness:** Browser automation inherently flaky
   - **Mitigation:** Retry logic (max 1), good wait strategies
   - **Acceptance:** Some flakiness expected

### Test Coverage Gaps
- **Visual regression:** Not covered (manual QA)
- **Accessibility:** Basic (automated tools), detailed (manual)
- **Browser compatibility:** Chrome only (Selenium), Firefox/Safari manual
- **Network resilience:** Basic timeout tests, not comprehensive

---

## Success Metrics

### Test Quality Metrics
- **Test execution time:** <20 minutes for full suite
- **Flakiness rate:** <5% (tests fail randomly)
- **Coverage:** >80% line coverage
- **Bug escape rate:** <10% (bugs found in production vs QA)

### Test Effectiveness Metrics
- **Defect detection rate:** >90% of bugs caught by tests
- **False positive rate:** <5% (test fails, but code is correct)
- **Regression prevention:** 0 regressions in tested areas

---

## Recommended Test Implementation Order

1. **Phase 1: Backend Auth (Week 1)**
   - UNIT-004 to UNIT-007 (session logic)
   - INT-004 to INT-015 (auth endpoints)
   - SEC-001, SEC-002 (security)

2. **Phase 2: Frontend Auth (Week 1-2)**
   - UNIT-008 to UNIT-012 (auth UI logic)
   - INT-016 to INT-021 (auth modal)
   - E2E-002 to E2E-004 (auth flows)

3. **Phase 3: Account Page (Week 2)**
   - UNIT-001 to UNIT-003 (tab navigation)
   - INT-001 to INT-003 (page structure)
   - E2E-001 (navigation)

4. **Phase 4: Fantrax Tab (Week 2-3)**
   - UNIT-013 to UNIT-017 (roster logic)
   - INT-022 to INT-029 (Fantrax UI)
   - E2E-005 to E2E-006 (full flows)

5. **Phase 5: Supporting Features (Week 3)**
   - UNIT-018 to UNIT-021 (misc)
   - INT-030 to INT-033 (misc)
   - E2E-007 to E2E-009 (gates & edge cases)

6. **Phase 6: Performance & Load (Week 3-4)**
   - LOAD-001 to LOAD-003
   - PERF-001 to PERF-003
   - SEC-003 to SEC-005

---

## Conclusion

This test design provides **comprehensive coverage** of the Fantrax account page enhancement with **67 test scenarios** across all test levels. The strategy emphasizes:

âœ… **Security first** - Cookie encryption, session isolation, premium enforcement
âœ… **Resource safety** - Selenium cleanup, concurrency limits, timeout handling
âœ… **User experience** - Auth latency expectations, error handling, cookie expiration
âœ… **Risk mitigation** - All 13 identified risks have dedicated test coverage

**Estimated Test Development Effort:** 20-25 hours
**Estimated Test Execution Time:** 20 minutes (full suite)

**Next Steps:**
1. Review and approve test design
2. Begin Phase 1 implementation (backend auth tests)
3. Set up CI/CD pipeline for automated execution
4. Schedule weekly security test runs

**Test Strategy Status:** âœ… **COMPLETE - READY FOR IMPLEMENTATION**

---

**Document Version:** 1.0
**Last Updated:** 2025-10-14
**Quinn (QA Test Architect)** ðŸ§ª
